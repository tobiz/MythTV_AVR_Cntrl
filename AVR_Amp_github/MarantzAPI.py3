#!/usr/bin/env python2.7
import subprocess 
from subprocess import Popen,PIPE
import time
import string
import socket
import sys
 
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.support.select import Select
from selenium.webdriver.firefox.options import Options

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as cond
from selenium.common.exceptions import NoAlertPresentException
from selenium.common.exceptions import TimeoutException

from selenium.webdriver.support import expected_conditions as EC


# Generated by Selenium IDE
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
  
class IP(): 
    def __init__(self, port, timer, av_url, browser):
        #print ("MarantzAPI with brackets")
        self.script = "./nc.sh"
        self.ip = av_url
        self.port = port
        self.timer = timer  # threading.Timer(10, self.disconnect)
                
        #print "url_chain: ", self.url_chain
        self.browser = browser
                
    def startBrowser(self, name):
    #
    # Browsers intended to be supported: firefox, chrome, ie, phantomjs
    # It has only been tested with Firefox, other browsers require code 
    # changes throughout.
    #
    # This code was finally worked out using the Selenium IDE software, a really
    # excellent piece of kit if perhaps lacking in the UI department.
    #
        try:
            if name == "firefox" or name == "Firefox" or name == "ff":
                #print("start browser name :Firefox")
                self.options = Options()
                self.options.headless = True
                driver = webdriver.Firefox(options=self.options)
                return driver
            elif name == "chrome" or name == "Chrome":
                print("start browser name :Chrome")
                driver = webdriver.Chrome()
                return driver
            elif name == "ie" or name == "Ie":
                print("start browser name :Ie")
                driver = webdriver.Ie()
                return driver
            elif name == "phantomjs" or name == "Phantomjs":
                print("start browser name :phantomjs")
                driver = webdriver.PhantomJS()
                return driver
            else:
                print ("Browser not supported")
        except Exception as msg:
            print(("message: %s" % str(msg)))
     
    def netcat(self, hostname, port, content):
        #print ("netcat: %s\n" % (content))
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        #deftimeout = s.gettimeout()
        #print "Default time out: ", deftimeout
        s.settimeout(1)
        
        try:
                s.connect((hostname, port))
        except:
            print ("Connection failed")
            return
            
        data = bytes(str(content + "\r").encode("utf-8"))
        #s.sendall(content + "\r")
        s.sendall(data)
        #print "Data sent: ", content
        
        amount_received = 0
        amount_expected = 1024
        #amount_expected = 20
        i = 1
        data_total = []
        while amount_received < amount_expected:
            try:
                    data = s.recv(1024).rstrip()
                    #print "No recv error. Count: ", i 
            except socket.timeout:
            		  #time.sleep(1)
                    #print "Socket timeout. Data Returned is: ", data_total, " Count: ", i
                    s.close()
                    time.sleep(1)
                    return data_total
            i += 1
            data_total.append(data) 
            amount_received += len(data)
            #print "Data Received: ",  (new_data), " Data Total: ", data_total, " Data len rx'd: ", len(data)
        print(("Data Total is: ", data_total)) 
        
    def write_command(self, command):
        #print ("\nPython write_command: %s" %(command))
        rtn = self.netcat(self.ip, self.port, command)
        return rtn
    
    def amp_assign(self, assign_mode):
        #
        # This function changes the Amp Assign mode by interfacing with
        # the web browser access to the AV Amp itself.  It has not been possible to do this
        # from the RS-232C/IP command set.  The Amp Assign mode needs to be set in order
        # to configure the speaker configurations from the command set.  This situation is mentioned
        # in a footnote in the command set definition spreadsheet
        #
        #print "Assign Mode: ", assign_mode
        child = {'Surround Back':1, 'ZONE2':2, 'Bi-Amp':3, 'Front B':4, 'Front Height':5}
        self.element1 = "http://" + self.ip + "/SETUP/SPEAKERS/AMPASSIGN/f_speakersetup.asp"
        #print "Element1 is: ", self.element1
        self.driver = self.startBrowser(self.browser)
        #self.driver.get("http://192.168.1.47/SETUP/SPEAKERS/AMPASSIGN/f_speakersetup.asp")
        try:
        		self.driver.get(self.element1)
        except:
        		print ("self.driver.get failed")
        self.driver.switch_to.frame(1)
        self.driver.find_element(By.NAME, "listAmpAssignMode").click()
        dropdown = self.driver.find_element(By.NAME, "listAmpAssignMode")
        
        element = "//option[. = " + "\'" + assign_mode + "\'" + "]"
        #print "Element is: ", element
        dropdown.find_element(By.XPATH, element).click()
        
        child_n = child[assign_mode]
        option = "option:nth-child(" + str(child_n) +  ")"
        #print "Option is: ", option
        self.driver.find_element(By.CSS_SELECTOR, option).click()
        
        self.driver.quit()
        


